## 死锁的处理. 
- 银行家 ?

- 如果是以下这种顺序? 
    P {
        P(mutex);
        P(empty);
        // ...
        V(mutex);
        V(full);
    }

    C {
        P(mutex);
        P(full);
        // ... 
        V(mutex);
        V(empty);
    }

- 会阻塞!!!
- 相互依赖...
- 形成了循环等待圈(环路等待)
- 互相等待对方造成死锁

### 死锁的成因
1. 资源互斥使用, 一旦占有别人无法使用
2. 资源不可抢占, 只能自愿放弃
3. 进程占有其他资源, 又不释放, 再去申请其他资源
4. 循环等待

### 死锁的处理方法
1. 死锁预防; 破坏死锁的必要条件条件. 
    - 一次申请所有资源
      1. 一次申请所有资源, 需要预知未来编程困难
      2. 分配资源很长时间才使用, 利用率低
    - 资源按顺序申请
      1. 仍然造成资源浪费
2. 死锁避免; 检测每个资源的请求, 如果造成超标, 就拒绝
    - 判断此次请求是否引起死锁, 判断所有进程存在一个可完成的执行序列p1, ... pn, 则称系统是安全的
    - 执行的代价很大... 
    - 假装分配, 算一下有没有安全序列.
    - 如果没有安全序列, 此次申请被拒绝, 说明可能造成死锁 
3. 死锁检测 + 恢复; 检测到死锁出现让进程回滚, 让出资源
    - 发现问题再处理
    - 找到死锁进程组(谁也执行不下去)
    - 挑一个进程再回滚
        - 怎么回滚? 回滚到有安全序列
        - 选择谁回滚? 
        - 怎么实现回滚? 难以实现
4. 死锁忽略; 就好像没出现死锁一样