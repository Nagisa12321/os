## 揭开的钢琴的盖子

### 从启动开始说起！

#### 神秘的黑色背后发生了啥? 
- 取指执行！

- 打开电源计算机的第一条指令是什么? (PC = ?)

1. 开机时cpu处于实模式
2. 开机时CS = 0xFFFF, IP = 0x0000
3. 物理地址 = CS << 4 + IP = 0xFFFF0; 寻址0xFFFF0(ROM BIOS映射区)
4. 检查RAM, 键盘, 显示器, 软硬键盘
5. 将磁盘0磁道0扇区读入0x7c00处
	- 一个扇区： 512字节
	- 把磁盘中的。。。读出来放到内存0x7c00处
	- 磁盘0磁道0扇区是什么呢? 引导扇区！
		- 做了什么事? 
		- 引导扇区代码bootsect.s(汇编)
			- **为什么不用c?**
				- c要经过编译, 编译之后可能无法对内存进行控制
				- 汇编操作的是硬件, 能起完整控制的作用
```
	--> BOOTSEG = 0x07c0
	--> INITSEG = 0x9000
	--> SETUPSEG = 0x9020
start: 	
	mov ax, #BOOTSEG	mov ds, ax --> ds = 07c0
	mov ax, #INITSEG	mov es, ax --> es = 9000
	mov cx, #256
	sub si, si			sub di, di --> 清零
	--> tips： ds:si(7c00), es:di(90000)
	
	rep movw --> 重复移动字
	--> rep:   重复执行该语句直至寄存器cx为0
	--> movw： 将DS：SI的内容送至ES：DI，note! 是复制过去，原来的代码还在
	--> 移动256次(512字节): 把bootstep的内存中的代码从7c00挪到90000
	--> 要**腾出空间**
	
	jmpi go, INITSEG -> 会把go赋给ip, INITSEG赋给cs.
	--> 跳到，INITSEG(0x9000)：go处执行
	--> bootstep已经放在内存90000的地方, 而bootstep之后就是go
	--> 意思是跳到90000之后的bootstep之后(其实是顺序执行, 但必须写. )
	go: .....
	load_setup: .....
	.....
	.....
	
	int 0x13 --> 什么是13: 读磁盘中断
	--> ah = 0x02 - 读磁盘, al = 扇区数量
	--> cl = 柱面号, cl = 开始扇区
	--> dh = 磁头号, dl = 驱动器号
	--> es:bx = 内存地址
	 第二扇区开始读, 读STUPLEN个扇区, 柱面号为0, 开始扇区为2
	--> 磁头号为0, 驱动器号为0. 
	--> 内存地址是: 90200(读512字节)
	j 	load_setup 重读
	
	
	Ok_load_setup: 
	
	
	......
	
	
	int 0x10 --> 显示字符中断 - 网上查阅！
	
	
```
6. 设置cs = 0x07c0, ip = 0x0000
	- bios从现在要调到0x7c00处

#### 关于"通用图灵机"
- 把程序放到内存中, 用指针指向它
- [自动]取指执行