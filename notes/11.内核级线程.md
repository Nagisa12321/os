## 内核级线程
- 用户级线程的切换是内核级线程切换的一个部分

## 为什么要有核心级线程, 有什么用? 
- 多核要想充分发挥作用, 就要用到核心级线程
- 多处理器和多核的区别: 多处理器用的是多套映射(MMU), 多核只用到一套映射
- 并行!!!, 之前的用户级线程是并发. 操作系统看不到用户级线程, 也就无法分配硬件

## 和用户级相比, 核心级线程有什么不同? 
- 本质区别: 从多个栈 -> 多套栈, 因为在用户态和核心态都要进行函数调用。 
- 在核心级线程, 一个TCB关联一套栈, 而且是放在内核里边

## 用户栈和内核栈之间的关联
- 在用户态执行的时候, 一旦int触发, 操作系统会用硬件方式找到本线程对应的内核栈
- 用户态的ss,sp,cs,ip入栈, 相当于保存用户态状态
- iret的时候会返回用户态, 出栈各种寄存器值, 恢复用户态(回弹完成指令的跳转)

e.g
```
100:    A() {
            B();
104     }

200     B() {
            read();
204     }

300     read() {
            int 0x80;
304     }

system_call:
    call sys_read;

1000
2000:   sys_read() {  }

- 用户栈
高
104
204
低
- 内核栈
ss:sp
eflags
304
cs
1000
```
## 如何进行switch_to? 

- 首先switch_to在核心态中执行. 
- 线程S的TCB通过switch_to切换到线程T的TCB, 线程T的TCB关联着线程T的核心栈
- 线程T的核心栈关联着线程T的用户栈

## 内核级线程切换switch_to的五段论

1. 中断入口
    - 要把内核栈关联上用户栈, 为了切换做准备
    - 然后进行中断处理

2. 中断处理, 引发切换
3. 找到TCB
4. 根据TCB完成内核栈的切换. 
5. 中断出口:
    - iret返回, 
    - 弹出栈中的各个用户态的现场

## 如何实现ThreadCreate
- 就是要做成那个样子(能切换的样子)

## 用户级线程和核心级线程的对比: 
- 见网课