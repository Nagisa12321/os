## 信号量的临界区保护. 

- 靠临界区保护信号量
- 靠信号量来让进程走走停停

### 为什么要保护信号量/引出临界区
- 不光要读信号量, 也要写信号量!(共同修改变量)
- 进程的调度是随机的
- 有一些可能性的调度会使得共享数据发生错误
- 竞争条件!!!

- 直观想法: 在写共享变量empty之前阻止其他进程访问empty!  (给empty上锁)
- 就是: 一段代码一次只能允许一个进程进入. (原子操作!)

- 临界区: 一次只允许一个进程进入 的 该进程的那一段代码(成对出现. )

### 怎么保护信号量/实现临界区
- 基本原则: 
    1. 互斥!
    2. 有空让进
    3. 有限等待
- 三种方法!

- 软件方法
    1. 轮换法
    ```
    P1 {
        while (turn != 0);
        // 临界区
        turn = 1;
        // 剩余区
    }

    P2 {
        while (turn != 1);
        // 临界区
        turn = 0;
        // 剩余区
    }

    ```

    1. 标记法

    ```
    // !!会死锁
    P1 {    
        flag[0] = true;
        while (flag[1]);
        // 临界区
        flag[0] = false;
        // 剩余区
    }

    P2 {    
        flag[1] = true;
        while (flag[0]);
        // 临界区
        flag[1] = false;
        // 剩余区
    }
    ```


    1. 非对称标记(Peterson)
    ```
    P1 {
        flag[0] = true;
        turn = 1;
        while (flag[1] && turn == 1);
        // 临界区
        flag[0] = false;
    }

    P2 {
        flag[1] = true;
        turn = 0;
        while (flag[0] && turn == 0);
        // 临界区
        flag[1] = false;
    }
    ```
    - 互斥进入: 假设两个人都在临界区, 那么flag[0] == flag[1] == true, turn == 0 == 1, 因此不可能
    - 有空让进: P0不在临界区, 那么flag[0] == false || turn == 1;那么P1能进入
    - 有限等待: 一个进程不可能循环跑(类似值日)

    1. 多进程怎么办? -- 面包店算法
    - 仍然是标记和轮转结合
    - 每个进程获得一个序号, 序号最小的进入
    - 怎么标记? 离开时候序号为0, 不为0的序号就是标记 

- 硬件方法: 中断
    - 多cpu不好使
    ```
    cli();
    // 临界区
    sti();
    ```
    -- 中断的本质: intr寄存器
    - cpu每执行一条指令都会看有没有中断...? 在寄存器里面
    - 关中断, 就是cpu不看!
    - 多cpu: 每个cpu都有这么个玩意, 

- tsl - test and set lock!

    bool TestAndSet(bool x) {
        bool rv = x;
        x = true;
        return rv;
    }

- 另外还有xchg... .