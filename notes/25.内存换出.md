## 内存换出

- 一直get_free_page()也不行


## 运用什么算法找一页进行淘汰
-- 评测标准: 缺页次数
- FIFO
    - 有可能刚换出又换入
    - 极为慢 
- MIN
    - 将最远使用的淘汰
    - 这个要预测未来
    - 怎么可能实现.? 
- LRU: 选最近最长一段时间没有使用的页面淘汰 -- 过去历史预测未来(局部性!)


## LRU的准确实现 -- 时间戳
- 为每个页维护一个时间戳, 表明什么时候使用过, 要换出的时候就看看哪一页是时间戳最小的, 说明最久没用过, 就把哪一页给换出

## LRU准确实现 -- 维护一个页面栈 
- 每执行一条指令都要往下沉, 代价也很大

## LRU近似实现 - 将时间计数变为是和否
- 为每个页加一个引用位(ref bit)
- 最近访问过就是1, 
- 淘汰算法: 是1清零, 是0就淘汰!
- 可以放在页表中, 让MMU代劳

- 别名clock算法

- 现实情况是缺页很少发生, 导致全是1
- 当有缺页, 指针会转一圈, 然后拿出一个
- 这样就退化成FIFO了!!!

## CLOCK算法的改进 -- 
- CLOCK记录了太长的历史信息, 因此要定时清除R位
- 再来一个扫描指针
- 真的是clock!!!
- 快指针负责清除R位, 放在时钟中断
- 慢指针来选择淘汰页, 放在缺页中断


## 颠簸/抖动
- 指的是随着进程个数的增加. CPU的利用率增加
- 但是进程太多CPU利用率急剧下降
- 就是因为每个进程分配的实际物理页少, 频繁换入换出
- 就是磁盘和内存之间不停进行页面换入换出

## 工作集?

## 给一个进程要分配多少页框?
- 最好是动态调整
- 也要限制进程的数量