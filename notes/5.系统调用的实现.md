## 系统调用的实现

- 插座背后的故事

### whoami? 
```
// 用户程序
main() {
	whoami();
}

// 系统调用
whoami() {
	printf(100, 8);
}

100: jt
```

- 为啥用户程序不能直接 printf(100, 8); ? (直接访问内核内存? )
	- 禁止随意jump!~
	- why不能这样? 
		- 首先是安全性问题(用户名密码存在内存中)
	- 怎么让它不这样? 
		- 区分用户态和核心态 -> 是一种处理器的**硬件**设计
		- 内核(用户)态, 内核(用户)段
		- CS:IP是当前指令, CS最低两位来表示内核态和用户态: 0是内核态, 3是用户态(数字越大越低)
		- 内核态可以访问任何目标数据, 用户态不能方位内核数据
		- 对于指令的跳转也实现了隔离
		- CPL(CS (当前特权级)), DPL(目标特权级)  => CPL <= DPL 当前特权级大于目标特权级才能执行

		- 整理: 
			1. 在系统初始化的时候(head.s 执行的时候, 会针对内核态的数据建立GDT表项, 对应的DPL = 0)
			2. 初始化好以后, 进入用户态执行, 启动shell, 让cs的cpl置为3, 启动用户程序的时候, 用户程序的对应CPL = 3. 

	- 那我应该哪样？ 
		- 硬件提供了主动进入内核的方法 -> 那就是中断指令int(唯一)
		- int指令将使得cs中的cpl改成0, "进入内核"
		- 这是用户程序发起的调用内核代码的唯一方法
		
		- 系统调用的核心
			1. 用户程序中包含一段包含int指令的代码(库函数)
			2. 操作系统写中断处理, 获取想调程序的编号
			3. 操作系统根据编号执行响应的代码

		- 详见源码3.0
			- 大火都是从int 0x80 进入系统调用
			- 宏观 -> **将一个int系统调用号置给eax**(&system_call的时候取并执行), 然后调用int 0x80 ==> 到内核了

		- int 0x80 的中断处理
			1. 查idt表 -> 在idt表中查出中断处理函数, 跳到那儿去执行

			- 为什么是0x80? 
				- set_system_gate(0x80, &system_call); -> 已经规定好0x80就是做中断处理
				- 调用int 0x80 会把dpl变成3(目标特权级)

			2. 查表用段选择符和段偏移设置成新的pc, cs=8, ip=&system_call ==> 内核代码段, 就是内核中的system call函数
			- cs = 8 的时候 cpu 的 cpl = 0!!! (cs最后两位 -> 00)

		- system_call
```
// ....
call _sys_call_table(,%eax,4) ==> _sys_call_table(系统调用函数表) + 4 * %eax 就是响应系统调用处理函数的入口
							  ==> why 4? 
								 - 每个系统调用函数占4字节
// ....
```s

		- _sys_call_table 
			- 是一个全局的函数数组
			- 在sys.h中ss

- printf过程
1. printf系统调用(用户态)
2. printf展开, 其中有int 0x80.(用户态)
3. 从idt表找到80对应表项(system_call函数地址, 在初始化时已然设置好(CS = 8, IP = &system_call))
3. system_call中断处理(核心态) 
4. call _sys_call_table(,%eax,4) 跳到系统调用函数
	