## 内存的使用和分段

### 如何让内存用起来???

- 取指执行, 从内存取!!!
- 将程序放到内存中, pc指向开始的地址
- 实现逻辑地址和物理地址的转换

- 找一段空闲的内存把程序放进来, 并且实现逻辑地址到物理地址的转换, 程序就能顺利执行.  (重定位)

- 什么时候做重定位? 
    - 编译的时候
    - 载入的时候(灵活, 根据内存中哪一段是空闲的, 再处理)

- 很多时候, 程序载入之后还需要移动
    - 交换(swap): 进程换入内存和换出内存. 当内存空间不足的时候会将一些进程换出内存, 这些进程可能是阻塞或者睡眠状态, 当他们换入内存的时候, 可能原本的物理地址就被占有了, 因此我们要分配新的物理地址(偏移量)给它们
    - 因此重定位的最佳时机: 运行时重定位
    - 每一条执行指令都要从逻辑地址计算出物理地址----地址翻译!!!!

- 基地址(base)放在哪里? 
    - PCB

- 怎么让程序运行起来?
1. 程序编译好, 地址不需要任何修改
2. 接着我们想让程序执行起来, 要先创建进程, PCB. 在内存中找一段空闲的内存, 然后把空闲地址找到(1000), 然后把1000赋给pcb, 把这段程序载入内存中
3. pc置好初始地址, 然后开始执行, 每次执行一条指令都要进行地址翻译

### 引入分段: 是将整个程序一起载入内存中吗? 

- 分治思想: 可能程序段只读, 数据段可写
- 提升了内存的效率: 不用移动全部程序!


### 什么是GDT/LDT? 

- LDT表是进程的表: 
    - 进程的数据/代码段的起始地址保存在这个表中(采用段选择子的方式保存)
    - 而这个表保存在进程PCB之中
    - 每次执行一条指令查询这个表然后找到真实的物理地址去执行
    - 怎么找? 通过选择子进行匹配可以知道很多信息!

### 寻址方式(P148)
1. 通过ds(段选择子, 通过一定的位运算可以得知各种信息包括段的物理起始地址) + gdtr(存储段描述符表起始地址)找到相应的段描述符表项
通过表项得出ldt表起始地址
找到ldt表, 找到对应段起始地址 + 偏移
   
=> 这样我们就找到线性地址了
=> 如果没有采用分页, 我们这种地址就是实际物理地址

1. 每个进程都有一个ldt表
2. 通过ldtr获取ldt表的位置
    1. ldtr是一个寄存器, 存储一个段选择子
    2. 通过该段选择子在gdt表中一查, 得出ldt表的位置
    3. 前往ldt表在内存的位置, 得知各个段的位置~