## 进程通信的几种方式
1. 共享内存地址通信: 假如进程a要和进程b通信, 进程a不能直接访问进程b的地址空间, 因为每个进程的地址空间都是独立的
因此, 进程a会把通信内容放到共享内存块, 在共享内存存取数据是互斥的, 因此进程b要等a释放对共享内存块的锁才能访问, 这样就完成了进程间通信
这种共享内存有两种: 基于数据结构的共享内存/基于存储区的共享内存
2. 管道通信: 我的理解就是假如有进程a和进程b想要通信, 进程a好像给进程b开了一条半双工的管道一样, 其实这条管道就是一页, 4KB
对于这样一条管道也是互斥的而且满足写完才能读, 读完才能写
3. 类似计网的报文, 消息队列通信, 发送原语接收原语 ,进程a想要和进程b通信, 会把消息放在b的消息队列中, 或者放在信箱中

## 说说核心态和用户态
- CPU处于用户态, 只能执行非特权指令, CPU处于和心态, 能执行非特权指令和特权指令
- 这两种状态是程序状态字寄存器里面的某一位, 0为用户态1为核心态
- 根据这两种状态分为内核程序和应用程序
- 操作系统的时钟管理, 原语操作,中断处理, 进程调度都是核心程序完成的, 至于设备管理哪些要看你是什么操作系统
- 如果是微内核那就是用户态执行, 微内核结构清晰但速度慢, 大内核要写大量核心程序代码, 但是速度快

## 线程和进程的区别是什么, 线程的实现方式? 
- 线程是程序运行的最小单位, 进程是系统资源分配的最小单位, 线程几乎不拥有系统资源, 多个线程可以共享同个资源, 多个进程无法共享资源, 只能通信
- 切换开销: 线程的切换开销比较小, 可以在用户程序中自行实现. 进程的切换开销比较大, 要调用中断跳到内核态来进行进程切换, 
而且要保存上下文, 重新载入新的进程的上下文, 从PCB进程控制块来载入. 

- 内核级线程/用户及线程

## 说说用户级线程和内核级线程? 多线程模型, 优点? 
- 用户级线程顾名思义, 就是用户能看到的线程。
- 内核级线程和用户及线程相反, 是操作系统能看到的线程。因为操作系统只能看到内核级线程, 所有操作系统的时间片只会分给内核级线程
- 举个例子， 如果一个进程有多个用户级线程, 那其实操作系统不知道, 只知道这是一个进程罢了

- 一对多, 一对一, 多对多
- 一对多: 多个用户及线程对应一个内核级线程
	- 优点: 线程的切换只在同一个进程中, 开销小, 而且保持在用户态. 
	- 缺点: 整个进程只能占有CPU的一个核, 因此当有一个用户及线程阻塞的时候, 其他也会阻塞. 并发度不高

- 一对一: 一个用户及线程对应一个内核级线程
	- 优点: 可以使用CPU的多个核, 即使一个线程被阻塞了, 其他线程也不会阻塞, 并发度高
	- 缺点: 切换线程要在内核态中执行, 所以开销大

- 多对多: m映射n

## 说说三层调度。 
- 高级调度(作业调度): 进程从无到有的过程, 无 --> 创建 --> 就绪。 一般都是从外存加载放到内存中, 并设置响应PCB
- 中级调度(内存调度): 如果内存不足, 会把一部分程序设为挂起态, 放到外存中的挂起队列, PCB仍然保留内存中, 因为该进程还属于调度管理范围
- 初级调度(进程调度): 理解为进程调度: 就绪 --> 运行

## 讲讲进程调度方式? 什么时候不能进程调度？ 
- 进程的调度方式分为抢占式和非抢占式
- 不能: 
	1. 处理中断的过程中
	2. 操作系统内核临界区
	3. 原子操作的过程中

## 说说几种调度算法
从简单到复杂说起
- 优点
- 缺点
- 是否引起饥饿
1. 先来先服务FCFS: 维护一个队列, 进程按照加入时间放到队尾
	- 优点： 比较公平
	- 缺点: 花费时间比较小的线程要等待很久
	- 是否引起饥饿: 否
2. 短时间优先SJF: 
	1. 非抢占式: 每次都取出所有当前线程中的花费时间最小的来执行
	2. 抢占式：每次都取出所有当前线程中的花费时间最小的来执行, 当有一个新的进程加入时, 
		会先检查当前运行进程的剩余时间, 如果剩余时间大于加入进程的运行时间, 那么会抢占当前进程
		
	- 优点：用户等待时间总体比较短, 对花费时间比较短的进程友好
	- 缺点: 用户虚假报时, 对长时间作业的进程不友好
	- 是否引起饥饿: 会, 如果一直有短时间进程加入, 那么长时间的进程得不到运行

3. 高相应比有限算法HRRF
	相应比就是 [用户等待时间 + 服务时间 / 服务时间]
	
	- 优点：用户等待时间总体比较短, 不管进程服务时间长短都可以充分得到运行. 
	- 缺点: 
	- 是否引起饥饿: 不会. 因为等待时间越久相应比越高

4. 时间片轮转
	- 类比一下刚刚说的先来先服务, 只不过加了一个时间片, 进程在时间片内如果没有执行完, 将会被抢夺运行权
	放到队尾, 
	
	- 优点：用户等待时间总体比较短, 不管进程服务时间长短都可以充分得到运行. 
	- 缺点: 高频路切换进程, 开销比较大. 不能区分紧急任务
	- 是否引起饥饿: 不会. 等待时间一致

5. 线程优先级
	- 类比高响应比, 把对比的方式改为优先级。 也分为抢占式和非抢占式

	- 优点：区分紧急任务
	- 缺点: 用户虚假报时, 对低优先级的进程不友好
	- 是否引起饥饿: 会

6. 多级反馈队列
	- 将进程等待区域分为多级队列, 按优先级从高到低, 时间片从小到大排列（指数）
	1. 进程加入时从最高优先级加入
	2. 一个进程执行完时间片若还没结束将被放至下一级队列队尾
	3. 当有比当前优先级更高的进程加入的时候, 会抢占当前进程, 当前进程会被放到本层队尾
	4. 只有k层没进程, k+1层才会得到执行

## 进程互斥的实现方法(软件/硬件)? 
1. 单标志法
```
int a = 0; // 标志

// 进程1
P1 {
	while (a == 0);
	// dosomething ... 
	a = 1;
}

// 进程2
P2 {
	while (a == 1);
	// dosomething ... 
	a = 0;
}
```
2. 双标志法
(1) 先判断
```
int[] flag = new int[2];
flag[0] = false; // 进程进入临界区意愿
flag[1] = false;

// 进程1
P1 { 
	while (flag[1]); 
	flag[0] = true;
	// dosomething ... 
	flag[0] = false;
}

// 进程2
P2 { 
	while (flag[0]); 
	flag[1] = true;
	// dosomething ... 
	flag[1] = false;
}
```
(2) 后判断
```
int[] flag = new int[2];
flag[0] = false; // 进程进入临界区意愿
flag[1] = false;

// 进程1
P1 { 
	flag[0] = true;
	while (flag[1]); 
	// dosomething ... 
	flag[0] = false;
}

// 进程2
P2 { 
	flag[1] = true;
	while (flag[0]); 
	// dosomething ... 
	flag[1] = false;
}
```
3. Peterson算法
```
int[] flag = new int[2];
flag[0] = false; // 进程进入临界区意愿
flag[1] = false;
int turn = 0; // 进程谦让位

// 进程1
P1 { 
	flag[0] = true;
	turn = 1;
	while (flag[1] && turn == 1); 
	// dosomething ... 
	flag[0] = false;
}

// 进程2
P2 { 
	flag[1] = true;
	turn = 0;
	while (flag[0] && turn == 0); 
	// dosomething ... 
	flag[1] = false;
}


- 硬件

1. 中断实现互斥
关中断; 
// do something
开中断; 

2. turn and set lock 
bool lock;
bool turnAndSetLock(bool lock) {
	bool old = lock;
	lock = true;
	return lock;
}

while (turnAndSetLock(lock));
// do some thing
lock = false;

3. swap (XCHG)
lock = false; 

// 进程
P {
	bool tmp = true;
	while (tmp) { swap(lock, tmp); }
	// do some thing
	lock = false;
}
```
## 原语具体怎么实现的? 
- 首先原语是在内核态中完成的
- 通过关中断和开中断实现
- 有创建进程/阻塞唤醒/销毁进程原语
## 信号量怎么实现的? 有什么类型?
## 说说两种类型的PV操作
1. 整形信号量
```
int mutex = 1; // 系统资源数目

void wait(int mutex) {
	while (mutex == 0) ;
	mutex--;
}

void signal(int mutex) {
	mutex ++;
}

// 
P1 {
	wait(mutex);
	// 访问临界资源
	signal(mutex);
}
P2 {
	wait(mutex);
	// 访问临界资源
	signal(mutex);
}
```

2. 结构型信号量
```
struct {
	int val; // 资源数目
	struct process queue; // 等待队列
} semaphorn

semaphorn mutex; // 系统资源数目
mutex.val = 1;

void wait(int mutex) {
	mutex.val--;
	
	if (mutex.val < 0) {
		// 阻塞原语
		block(mutex.queue);
	}
}

void signal(int mutex) {
	mutex.val++;
	
	if (mutex.val <= 0) {
		// 唤醒原语
		wakeup(mutex.queue);
	}
}

// 
P1 {
	wait(mutex);
	// 访问临界资源
	signal(mutex);
}
P2 {
	wait(mutex);
	// 访问临界资源
	signal(mutex);
}
```

## PV操作是怎么实现互斥, 同步, 前驱的？ 

## 说说生产者和消费者问题(多消费者生产者呢? )

## 说说吸烟者问题

## 说说读者写着问题

## 说说管程

## 死锁产生的条件? 

## 说说死锁和死循环、饥饿的区别

## 怎么避免死锁? 

## 说说银行家算法? 

## 说说死锁检测算法? 


数据密集型应用系统设计